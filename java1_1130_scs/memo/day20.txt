day10

0. 복습
Object 클래스는
모든 클래스의 최상위 조상 클래스


1. toString()
	Object의 toString()은 참조값을 문자열 형태로 반환한다
	(클래스경로와이름@16진수로 변환된 해쉬코드)
	참조변수를 출력 메소드로 추력하면 항상 toString()이 사용된다
	-> 참조값이 나오는 이유
	toString()을 통해 출력되는 문자열을 바꾸고 싶으면 재정의해서 사용하면 된다
	
2. equals()
	Object의 equals()는 ==과 같다 (참조값 비교)
	String의 equals()는 재정의 되어 객체가 가진 값을 비교한다
	-> 문자열 비교는 equals()를 사용해야한다
	우리가 만든 클래스 객체를 비교하고 싶다면, 비교 기준을 재정의하여 사용할 수 있다


3. hashCode()
	Object의 hashCode()는 객체의 주소값을 특정 알고리즘을 거쳐서 정수값으로 반환한다
	자바에서는 equals()를 재정의하면 hashCode()도 재정의하도록 권장한다
	(두 객체의 equals()가 true라면 hashCode()도 동일하게 나오도록 재정의하는 것을
	 권장함)

Wapper Class
기본 자료형들의 클래스 타입


기본 타입		wrapper 클래스
int		Integer
long		long
double		Double
float		Float
boolean		Boolean
char		Character

클래스타입 변수 = new 클래스타입(일반타입의 값);		// boxing 권장하지 않음
클래스타입 변수 = 클래스타입.valueOf(일반타입의 값);	// boxing
기본자료형 변수 = 객체.OOOValue();			// unboxing


JDK4 버전 이상부터는 auto boxing과 auto unboxing을 지원한다
클래스타입 변수 = 일반타입의 값; // auto boxing
일반타입 변수 = 객체;	// auto unboxing

boxing : 기본 타입의 값을 wrapper 클래스의 객체로 변환
unboxing : wrapper 클래스 객체에서 기본 타입으로 값으로 변환

Wrapper Class 사용하는 이유
원시타입(기본타입)을 박싱하면 다양한 메소드를 제공받을 수 있다
여러 기본타입을 하나의 타입으로 묶기 위해서는 반드시 클래스타입(Wrapper Class)
으로 사용해야 되고 이때는 박싱을 해줘야 한다

	- 클래스 타입은 다양한 메소드 제공받을 수 있다
	- 자바에서는 클래스타입이 갖는 이점이 많다
	- api에서 제공하는 여러 메소드는 매개변수로 클래스타입(Object)를 받는 경우
	  기본자료형을 넘겨 줄 수 없으므로 박싱을 해줘야한다


1. 자료구조와 알고리즘
	자료구조 : 의미없이 데이터를 하나의 정보로 만들어주는 알고리즘의 집합
		 수집한 자료를 저장하는 방법
	알고리즘 : 어떤 문제가 발생되었을 때 해결할 수 있는 순서 혹은 절차

	사전에서 단어 찾기
	java => a ~ z 사전의 첫페이지붙터 끝까지 찾는 방법
		사전은 알파벳 순서대로 정렬되어있음을 알고 찾는 방법

컬렉션 프레임워크(Collection Framework) : 자료구조
	많은 데이터를 쉽고 효과적으로 관리 할 수 있는 표준화된 방법을
	제공하는 클래스들의 집합
	List
	Set
	Map

List 인터페이스 extends Collection
	데이터 순서를 보장한다
	중복된 값을 허용한다

List 구현 클래스
	Vector : 용량관리, 보안성강화, 처리량 감소
	LinkedList : 추가, 삭제는 빠르지만 검색(탐색)이 상대적으로 느리다
	ArrayList : 배열과 동일하게 인덱스로 데이터를 관리한다
		    추가, 삭제는 상대적으로 느리지만 검색(탐색)이 빠르다

<E> : Element 제네릭
	타입 안정성을 보장하기 위한 기능
	결정되지 않은 타입을 매개변수로 처리하고 실제 사용할 때 매개변수를
	구체적인 타입으로 대체 시키는 기능

제네릭을 사용하는 이유
	1) 제네릭을 사용하지 않는다면 필드의 타입별로 클래스를 만들어야한다
	2) 제네릭 대신 Object 타입을 사용한다면 다운캐스팅을 해야한다
	3) 제네릭을 타입을 제한할 수 있다 (Object 타입은 모든 타입을 다 받는다)

배열과 ArrayList의 차이
	배열은 길이에 제한을 두어야할 때 자주 사용하고
	ArrayList는 몇개의 뎅티ㅓ가 들어올지 알 수 없을 때 사용된다

ArrayList메소드
	add() : 추가
	get(idx) : index 번호로 특정 값 가져오기
	remove(idx) : 삭제, int 타입으로 넘겨줘야함
			삭제한 요소를 반환
	remove(Integer.valueOf(값)) : 값으로 검색하여 삭제
	clear() : 전체 삭제
	contains() : 포함여부 검사, 리스트에 존재하면 true, 없으면 false 반환함
	indexOf(값) : 값으로 인덱스 가져오기, 해당 값의 인덱스 번호를 반환함
	set(idx, 수정할 값) : 수정, 수정할 인덱스 값을 넘겨주어 수정한다
			수정되기 전의 값을 반환한다

Set : 집합
	데이터 순서를 보장하지 않는다
	데이터의 중복을 허용하지 않는다
구현 클래스
HashSet
	set 인터페이스를 구현한 가장 대표적인 클래스
	중복되는 값을 저장하면 무시한다
	인덱스 존재하지 않아 순서를 보장하지 않으면 ArrayList나 배열처럼 값을
	가져오는 것이 불가능하다
	HashCode()가 반환하는 해시코드를 이용해서 데이터를 처리하며 속도가 상대적으로
	빠르다
	위의 특징 때문에 값의 존재 여부를 파악할 때 사용하기 좋다

Iterator
	컬렉션에 저장된 데이터들을 컬렉션의 종류와 상관없이 동일한 방식으로
	가져오기 위한 인터페이스(타입)
	어떤 자료구조든 Iterator로 변환하면 자기만의 방식의 순서를 만들고
	값을 가져올 수 있다
	값의 유무를 검사하거나 값을 가져올 때는 커서를 이용한다

	iterator()
		컬렉션 객체를 Iterator 타입으로 변환할 때 사용하는 메소드
	hashNext()
		다음값의 유무를 검사하여 boolean타입으로 변환한다
	next()
		다음 값을 가져온다. 아무 값도 없다면 예외가 발생한다